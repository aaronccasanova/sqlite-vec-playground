/**
pnpm tsx examples/chunks/ingest.js
*/
import ollama from 'ollama'
import { RecursiveCharacterTextSplitter } from '@langchain/textsplitters'
import { db } from '../db'

db.exec(/* sql */ `
  create table if not exists docs(
    id integer primary key autoincrement,
    content text
  )
`)

db.exec(/* sql */ `
  create table if not exists chunks(
    id integer primary key autoincrement,
    doc_id integer not null,
    chunk_index integer not null,
    content text not null,
    foreign key (doc_id) references docs(id) on delete cascade
  )
`)

db.exec(/* sql */ `
  create virtual table if not exists vec_chunks using vec0(
    chunk_id integer primary key,
    chunk_embeddings float[768]
  )
`)

// Since virtual tables in SQLite don't support foreign key constraints,
// we use a trigger to manually enforce referential integrity. This trigger
// mimics the `ON DELETE CASCADE` behavior, automatically deleting a vector
// from `vec_chunks` when its corresponding document is deleted from `docs`.
db.exec(/* sql */ `
  create trigger if not exists delete_chunk_embeddings
  after delete on chunks
  for each row
  begin
    delete from vec_chunks where chunk_id = OLD.id;
  end;
`)

const insertDoc = db.prepare(/* sql */ `
  insert into docs (content) VALUES (@content)
`)

const insertChunk = db.prepare(/* sql */ `
  insert into chunks (doc_id, chunk_index, content)
  values (@doc_id, @chunk_index, @content)
`)

const insertVecChunk = db.prepare(/* sql */ `
  insert into vec_chunks (chunk_id, chunk_embeddings)
  values (@chunk_id, @chunk_embeddings)
`)

const contents = getContents()

const splitter = new RecursiveCharacterTextSplitter({
  chunkSize: 1000,
  chunkOverlap: 200,
})

console.time('ingest')

await db.transaction(async () => {
  for (const content of contents) {
    const chunks = await splitter.splitText(content)

    const embedResponse = await ollama.embed({
      model: 'nomic-embed-text',
      input: chunks,
    })

    const docId = insertDoc.run({ content }).lastInsertRowid

    chunks.forEach((chunk, i) => {
      const chunkId = insertChunk.run({
        doc_id: docId,
        chunk_index: i,
        content: chunk,
      }).lastInsertRowid

      insertVecChunk.run({
        chunk_id: BigInt(chunkId),
        chunk_embeddings: new Float32Array(embedResponse.embeddings[i]),
      })
    })
  }
})()

console.timeEnd('ingest')

console.log(`✅ Ingested ${contents.length} docs.`)

function getContents() {
  return [
    `
---
title: React Router Home
order: 1
---

# React Router Home

React Router is a multi-strategy router for React bridging the gap from React 18 to React 19. You can use it maximally as a React framework or as minimally as you want.

## Getting Started

There are three primary ways, or "modes", to use it in your app, so there are three guides to get you started.

- [Declarative](./start/declarative/installation)
- [Data](./start/data/custom)
- [Framework](./start/framework/installation)

Learn which mode is right for you in [Picking a Mode](./start/modes).

## Using These Guides

Across the docs you'll see the following icons:

[MODES: framework, data, declarative]

<p></p>

These icons indicate which mode the content is relevant to.

Additional auto-generated reference documentation is available:

[Autogenerated Reference Docs ↗](https://api.reactrouter.com/v7/modules/react_router.html)

## Upgrading

If you are caught up on future flags, upgrading from React Router v6 or Remix v2 is generally non-breaking. Remix v2 apps are encouraged to upgrade to React Router v7.

- [Upgrade from v6](./upgrading/v6)
- [Upgrade from Remix](./upgrading/remix)
    `.trim(),
    `
---
title: Installation
order: 1
---

# Installation

[MODES: framework]

## Introduction

Most projects start with a template. Let's use a basic template maintained by React Router:

\`\`\`shellscript nonumber
npx create-react-router@latest my-react-router-app
\`\`\`

Now change into the new directory and start the app

\`\`\`shellscript nonumber
cd my-react-router-app
npm i
npm run dev
\`\`\`

You can now open your browser to \`http://localhost:5173\`

You can [view the template on GitHub][default-template] to see how to manually set up your project.

We also have a number of [ready to deploy templates][react-router-templates] available for you to get started with:

\`\`\`shellscript nonumber
npx create-react-router@latest --template remix-run/react-router-templates/<template-name>
\`\`\`

---

Next: [Routing](./routing)

[manual_usage]: ../how-to/manual-usage
[default-template]: https://github.com/remix-run/react-router-templates/tree/main/default
[react-router-templates]: https://github.com/remix-run/react-router-templates
    `.trim(),
    `
---
title: Routing
order: 2
---

# Routing

[MODES: framework]

## Configuring Routes

Routes are configured in \`app/routes.ts\`. Each route has two required parts: a URL pattern to match the URL, and a file path to the route module that defines its behavior.

\`\`\`ts filename=app/routes.ts
import {
  type RouteConfig,
  route,
} from "@react-router/dev/routes";

export default [
  route("some/path", "./some/file.tsx"),
  // pattern ^           ^ module file
] satisfies RouteConfig;
\`\`\`

Here is a larger sample route config:

\`\`\`ts filename=app/routes.ts
import {
  type RouteConfig,
  route,
  index,
  layout,
  prefix,
} from "@react-router/dev/routes";

export default [
  index("./home.tsx"),
  route("about", "./about.tsx"),

  layout("./auth/layout.tsx", [
    route("login", "./auth/login.tsx"),
    route("register", "./auth/register.tsx"),
  ]),

  ...prefix("concerts", [
    index("./concerts/home.tsx"),
    route(":city", "./concerts/city.tsx"),
    route("trending", "./concerts/trending.tsx"),
  ]),
] satisfies RouteConfig;
\`\`\`

If you prefer to define your routes via file naming conventions rather than configuration, the \`@react-router/fs-routes\` package provides a [file system routing convention][file-route-conventions]. You can even combine different routing conventions if you like:

\`\`\`ts filename=app/routes.ts
import {
  type RouteConfig,
  route,
} from "@react-router/dev/routes";
import { flatRoutes } from "@react-router/fs-routes";

export default [
  route("/", "./home.tsx"),

  ...(await flatRoutes()),
] satisfies RouteConfig;
\`\`\`

## Route Modules

The files referenced in \`routes.ts\` define each route's behavior:

\`\`\`tsx filename=app/routes.ts
route("teams/:teamId", "./team.tsx"),
//           route module ^^^^^^^^
\`\`\`

Here's a sample route module:

\`\`\`tsx filename=app/team.tsx
// provides type safety/inference
import type { Route } from "./+types/team";

// provides \`loaderData\` to the component
export async function loader({ params }: Route.LoaderArgs) {
  let team = await fetchTeam(params.teamId);
  return { name: team.name };
}

// renders after the loader is done
export default function Component({
  loaderData,
}: Route.ComponentProps) {
  return <h1>{loaderData.name}</h1>;
}
\`\`\`

Route modules have more features like actions, headers, and error boundaries, but they will be covered in the next guide: [Route Modules](./route-module)

## Nested Routes

Routes can be nested inside parent routes.

\`\`\`ts filename=app/routes.ts
import {
  type RouteConfig,
  route,
  index,
} from "@react-router/dev/routes";

export default [
  // parent route
  route("dashboard", "./dashboard.tsx", [
    // child routes
    index("./home.tsx"),
    route("settings", "./settings.tsx"),
  ]),
] satisfies RouteConfig;
\`\`\`

The path of the parent is automatically included in the child, so this config creates both \`"/dashboard"\` and \`"/dashboard/settings"\` URLs.

Child routes are rendered through the \`<Outlet/>\` in the parent route.

\`\`\`tsx filename=app/dashboard.tsx
import { Outlet } from "react-router";

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      {/* will either be home.tsx or settings.tsx */}
      <Outlet />
    </div>
  );
}
\`\`\`

## Root Route

Every route in \`routes.ts\` is nested inside the special \`app/root.tsx\` module.

## Layout Routes

Using \`layout\`, layout routes create new nesting for their children, but they don't add any segments to the URL. It's like the root route but they can be added at any level.

\`\`\`tsx filename=app/routes.ts lines=[10,16]
import {
  type RouteConfig,
  route,
  layout,
  index,
  prefix,
} from "@react-router/dev/routes";

export default [
  layout("./marketing/layout.tsx", [
    index("./marketing/home.tsx"),
    route("contact", "./marketing/contact.tsx"),
  ]),
  ...prefix("projects", [
    index("./projects/home.tsx"),
    layout("./projects/project-layout.tsx", [
      route(":pid", "./projects/project.tsx"),
      route(":pid/edit", "./projects/edit-project.tsx"),
    ]),
  ]),
] satisfies RouteConfig;
\`\`\`

Note that:

- \`home.tsx\` and \`contact.tsx\` will be rendered into the \`marketing/layout.tsx\` outlet without creating any new URL paths
- \`project.tsx\` and \`edit-project.tsx\` will be rendered into the \`projects/project-layout.tsx\` outlet at \`/projects/:pid\` and \`/projects/:pid/edit\` while \`projects/home.tsx\` will not.

## Index Routes

\`\`\`ts
index(componentFile),
\`\`\`

Index routes render into their parent's [Outlet][outlet] at their parent's URL (like a default child route).

\`\`\`ts filename=app/routes.ts
import {
  type RouteConfig,
  route,
  index,
} from "@react-router/dev/routes";

export default [
  // renders into the root.tsx Outlet at /
  index("./home.tsx"),
  route("dashboard", "./dashboard.tsx", [
    // renders into the dashboard.tsx Outlet at /dashboard
    index("./dashboard-home.tsx"),
    route("settings", "./dashboard-settings.tsx"),
  ]),
] satisfies RouteConfig;
\`\`\`

Note that index routes can't have children.

## Route Prefixes

Using \`prefix\`, you can add a path prefix to a set of routes without needing to introduce a parent route file.

\`\`\`tsx filename=app/routes.ts lines=[14]
import {
  type RouteConfig,
  route,
  layout,
  index,
  prefix,
} from "@react-router/dev/routes";

export default [
  layout("./marketing/layout.tsx", [
    index("./marketing/home.tsx"),
    route("contact", "./marketing/contact.tsx"),
  ]),
  ...prefix("projects", [
    index("./projects/home.tsx"),
    layout("./projects/project-layout.tsx", [
      route(":pid", "./projects/project.tsx"),
      route(":pid/edit", "./projects/edit-project.tsx"),
    ]),
  ]),
] satisfies RouteConfig;
\`\`\`

## Dynamic Segments

If a path segment starts with \`:\` then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as \`params\` to other router APIs.

\`\`\`ts filename=app/routes.ts
route("teams/:teamId", "./team.tsx"),
\`\`\`

\`\`\`tsx filename=app/team.tsx
import type { Route } from "./+types/team";

export async function loader({ params }: Route.LoaderArgs) {
  //                           ^? { teamId: string }
}

export default function Component({
  params,
}: Route.ComponentProps) {
  params.teamId;
  //        ^ string
}
\`\`\`

You can have multiple dynamic segments in one route path:

\`\`\`ts filename=app/routes.ts
route("c/:categoryId/p/:productId", "./product.tsx"),
\`\`\`

\`\`\`tsx filename=app/product.tsx
import type { Route } from "./+types/product";

async function loader({ params }: LoaderArgs) {
  //                    ^? { categoryId: string; productId: string }
}
\`\`\`

## Optional Segments

You can make a route segment optional by adding a \`?\` to the end of the segment.

\`\`\`ts filename=app/routes.ts
route(":lang?/categories", "./categories.tsx"),
\`\`\`

You can have optional static segments, too:

\`\`\`ts filename=app/routes.ts
route("users/:userId/edit?", "./user.tsx");
\`\`\`

## Splats

Also known as "catchall" and "star" segments. If a route path pattern ends with \`/*\` then it will match any characters following the \`/\`, including other \`/\` characters.

\`\`\`ts filename=app/routes.ts
route("files/*", "./files.tsx"),
\`\`\`

\`\`\`tsx filename=app/files.tsx
export async function loader({ params }: Route.LoaderArgs) {
  // params["*"] will contain the remaining URL after files/
}
\`\`\`

You can destructure the \`*\`, you just have to assign it a new name. A common name is \`splat\`:

\`\`\`tsx
const { "*": splat } = params;
\`\`\`

You can also use a splat to catch requests that don't match any route:

\`\`\`ts filename=app/routes.ts
route("*", "./catchall.tsx"); // catchall route,
\`\`\`

\`\`\`tsx filename=app/catchall.tsx
export function loader() {
  throw new Response("Page not found", { status: 404 });
}
\`\`\`

## Component Routes

You can also use components that match the URL to elements anywhere in the component tree:

\`\`\`tsx
import { Routes, Route } from "react-router";

function Wizard() {
  return (
    <div>
      <h1>Some Wizard with Steps</h1>
      <Routes>
        <Route index element={<StepOne />} />
        <Route path="step-2" element={<StepTwo />} />
        <Route path="step-3" element={<StepThree />} />
      </Routes>
    </div>
  );
}
\`\`\`

Note that these routes do not participate in data loading, actions, code splitting, or any other route module features, so their use cases are more limited than those of the route module.

---

Next: [Route Module](./route-module)

[file-route-conventions]: ../../how-to/file-route-conventions
[outlet]: https://api.reactrouter.com/v7/functions/react_router.Outlet.html
    `.trim(),
    `
---
title: Route Module
order: 3
---

# Route Module

[MODES: framework]

## Introduction

The files referenced in \`routes.ts\` are called Route Modules.

\`\`\`tsx filename=app/routes.ts
route("teams/:teamId", "./team.tsx"),
//           route module ^^^^^^^^
\`\`\`

Route modules are the foundation of React Router's framework features, they define:

- automatic code-splitting
- data loading
- actions
- revalidation
- error boundaries
- and more

This guide is a quick overview of every route module feature. The rest of the getting started guides will cover these features in more detail.

## Component (\`default\`)

The \`default\` export in a route module defines the component that will render when the route matches.

\`\`\`tsx filename=app/routes/my-route.tsx
export default function MyRouteComponent() {
  return (
    <div>
      <h1>Look ma!</h1>
      <p>
        I'm still using React Router after like 10 years.
      </p>
    </div>
  );
}
\`\`\`

### Props passed to the Component

When the component is rendered, it is provided the props defined in \`Route.ComponentProps\` that React Router will automatically generate for you. These props include:

1. \`loaderData\`: The data returned from the \`loader\` function in this route module
2. \`actionData\`: The data returned from the \`action\` function in this route module
3. \`params\`: An object containing the route parameters (if any).
4. \`matches\`: An array of all the matches in the current route tree.

You can use these props in place of hooks like \`useLoaderData\` or \`useParams\`. This may be preferable because they will be automatically typed correctly for the route.

### Using props

\`\`\`tsx filename=app/routes/my-route-with-default-params.tsx
import type { Route } from "./+types/route-name";

export default function MyRouteComponent({
  loaderData,
  actionData,
  params,
  matches,
}: Route.ComponentProps) {
  return (
    <div>
      <h1>Welcome to My Route with Props!</h1>
      <p>Loader Data: {JSON.stringify(loaderData)}</p>
      <p>Action Data: {JSON.stringify(actionData)}</p>
      <p>Route Parameters: {JSON.stringify(params)}</p>
      <p>Matched Routes: {JSON.stringify(matches)}</p>
    </div>
  );
}
\`\`\`

## \`loader\`

Route loaders provide data to route components before they are rendered. They are only called on the server when server rendering or during the build with pre-rendering.

\`\`\`tsx
export async function loader() {
  return { message: "Hello, world!" };
}

export default function MyRoute({ loaderData }) {
  return <h1>{loaderData.message}</h1>;
}
\`\`\`

See also:

- [\`loader\` params][loader-params]

## \`clientLoader\`

Called only in the browser, route client loaders provide data to route components in addition to, or in place of, route loaders.

\`\`\`tsx
export async function clientLoader({ serverLoader }) {
  // call the server loader
  const serverData = await serverLoader();
  // And/or fetch data on the client
  const data = getDataFromClient();
  // Return the data to expose through useLoaderData()
  return data;
}
\`\`\`

Client loaders can participate in initial page load hydration of server rendered pages by setting the \`hydrate\` property on the function:

\`\`\`tsx
export async function clientLoader() {
  // ...
}
clientLoader.hydrate = true as const;
\`\`\`

<docs-info>

By using \`as const\`, TypeScript will infer that the type for \`clientLoader.hydrate\` is \`true\` instead of \`boolean\`.
That way, React Router can derive types for \`loaderData\` based on the value of \`clientLoader.hydrate\`.

</docs-info>

See also:

- [\`clientLoader\` params][client-loader-params]

## \`action\`

Route actions allow server-side data mutations with automatic revalidation of all loader data on the page when called from \`<Form>\`, \`useFetcher\`, and \`useSubmit\`.

\`\`\`tsx
// route("/list", "./list.tsx")
import { Form } from "react-router";
import { TodoList } from "~/components/TodoList";

// this data will be loaded after the action completes...
export async function loader() {
  const items = await fakeDb.getItems();
  return { items };
}

// ...so that the list here is updated automatically
export default function Items({ loaderData }) {
  return (
    <div>
      <List items={loaderData.items} />
      <Form method="post" navigate={false} action="/list">
        <input type="text" name="title" />
        <button type="submit">Create Todo</button>
      </Form>
    </div>
  );
}

export async function action({ request }) {
  const data = await request.formData();
  const todo = await fakeDb.addItem({
    title: data.get("title"),
  });
  return { ok: true };
}
\`\`\`

## \`clientAction\`

Like route actions but only called in the browser.

\`\`\`tsx
export async function clientAction({ serverAction }) {
  fakeInvalidateClientSideCache();
  // can still call the server action if needed
  const data = await serverAction();
  return data;
}
\`\`\`

See also:

- [\`clientAction\` params][client-action-params]

## \`ErrorBoundary\`

When other route module APIs throw, the route module \`ErrorBoundary\` will render instead of the route component.

\`\`\`tsx
import {
  isRouteErrorResponse,
  useRouteError,
} from "react-router";

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>
          {error.status} {error.statusText}
        </h1>
        <p>{error.data}</p>
      </div>
    );
  } else if (error instanceof Error) {
    return (
      <div>
        <h1>Error</h1>
        <p>{error.message}</p>
        <p>The stack trace is:</p>
        <pre>{error.stack}</pre>
      </div>
    );
  } else {
    return <h1>Unknown Error</h1>;
  }
}
\`\`\`

## \`HydrateFallback\`

On initial page load, the route component renders only after the client loader is finished. If exported, a \`HydrateFallback\` can render immediately in place of the route component.

\`\`\`tsx filename=routes/client-only-route.tsx
export async function clientLoader() {
  const data = await fakeLoadLocalGameData();
  return data;
}

export function HydrateFallback() {
  return <p>Loading Game...</p>;
}

export default function Component({ loaderData }) {
  return <Game data={loaderData} />;
}
\`\`\`

## \`headers\`

Route headers define HTTP headers to be sent with the response when server rendering.

\`\`\`tsx
export function headers() {
  return {
    "X-Stretchy-Pants": "its for fun",
    "Cache-Control": "max-age=300, s-maxage=3600",
  };
}
\`\`\`

## \`handle\`

Route handle allows apps to add anything to a route match in \`useMatches\` to create abstractions (like breadcrumbs, etc.).

\`\`\`tsx
export const handle = {
  its: "all yours",
};
\`\`\`

## \`links\`

Route links define [\`<link>\` element][link-element]s to be rendered in the document \`<head>\`.

\`\`\`tsx
export function links() {
  return [
    {
      rel: "icon",
      href: "/favicon.png",
      type: "image/png",
    },
    {
      rel: "stylesheet",
      href: "https://example.com/some/styles.css",
    },
    {
      rel: "preload",
      href: "/images/banner.jpg",
      as: "image",
    },
  ];
}
\`\`\`

All routes links will be aggregated and rendered through the \`<Links />\` component, usually rendered in your app root:

\`\`\`tsx
import { Links } from "react-router";

export default function Root() {
  return (
    <html>
      <head>
        <Links />
      </head>

      <body />
    </html>
  );
}
\`\`\`

## \`meta\`

Route meta defines meta tags to be rendered in the \`<Meta />\` component, usually placed in the \`<head>\`.

<docs-warning>

Since React 19, [using the built-in \`<meta>\` element](https://react.dev/reference/react-dom/components/meta) is recommended over the use of the route module's \`meta\` export.

Here is an example of how to use it and the \`<title>\` element:

\`\`\`tsx
export default function MyRoute() {
  return (
    <div>
      <title>Very cool app</title>
      <meta property="og:title" content="Very cool app" />
      <meta
        name="description"
        content="This app is the best"
      />
      {/* The rest of your route content... */}
    </div>
  );
}
\`\`\`

</docs-warning>

\`\`\`tsx filename=app/product.tsx
export function meta() {
  return [
    { title: "Very cool app" },
    {
      property: "og:title",
      content: "Very cool app",
    },
    {
      name: "description",
      content: "This app is the best",
    },
  ];
}
\`\`\`

\`\`\`tsx filename=app/root.tsx
import { Meta } from "react-router";

export default function Root() {
  return (
    <html>
      <head>
        <Meta />
      </head>

      <body />
    </html>
  );
}
\`\`\`

The meta of the last matching route is used, allowing you to override parent routes' meta. It's important to note that the entire meta descriptor array is replaced, not merged. This gives you the flexibility to build your own meta composition logic across pages at different levels.

**See also**

- [\`meta\` params][meta-params]
- [\`meta\` function return types][meta-function]

## \`shouldRevalidate\`

In framework mode, route loaders are automatically revalidated after all navigations and form submissions (this is different from [Data Mode](../data/route-object#shouldrevalidate)). This enables middleware and loaders to share a request context and optimize in different ways than then they would be in Data Mode.

Defining this function allows you to opt out of revalidation for a route loader for navigations and form submissions.

\`\`\`tsx
import type { ShouldRevalidateFunctionArgs } from "react-router";

export function shouldRevalidate(
  arg: ShouldRevalidateFunctionArgs,
) {
  return true;
}
\`\`\`

[\`ShouldRevalidateFunctionArgs\` Reference Documentation ↗](https://api.reactrouter.com/v7/interfaces/react_router.ShouldRevalidateFunctionArgs.html)

---

Next: [Rendering Strategies](./rendering)

[fetch]: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
[loader-params]: https://api.reactrouter.com/v7/interfaces/react_router.LoaderFunctionArgs
[client-loader-params]: https://api.reactrouter.com/v7/types/react_router.ClientLoaderFunctionArgs
[action-params]: https://api.reactrouter.com/v7/interfaces/react_router.ActionFunctionArgs
[client-action-params]: https://api.reactrouter.com/v7/types/react_router.ClientActionFunctionArgs
[error-boundaries]: https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary
[use-route-error]: https://api.reactrouter.com/v7/functions/react_router.useRouteError
[is-route-error-response]: https://api.reactrouter.com/v7/functions/react_router.isRouteErrorResponse
[cache-control-header]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
[headers]: https://developer.mozilla.org/en-US/docs/Web/API/Response
[use-matches]: https://api.reactrouter.com/v7/functions/react_router.useMatches
[link-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link
[meta-element]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
[meta-params]: https://api.reactrouter.com/v7/interfaces/react_router.MetaArgs
[meta-function]: https://api.reactrouter.com/v7/types/react_router.MetaDescriptor.html
[use-revalidator]: https://api.reactrouter.com/v7/functions/react_router.useRevalidator.html

    `.trim(),
  ]
}
